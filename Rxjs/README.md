# 一: Rx 之前的一些基础知识
   本文借鉴[简书](http://www.jianshu.com/u/d01a391b4a74)
   一个应用，当处理少量数据时，可以保证用户界面响应迅速，动画流畅；但是面对大量数据涌入的时候，还能保证以上要求这就叫可扩展性和可伸缩性。
## 同步和异步
   同步就是代码一条条按顺序想下执行，但是遇到耗时间的io操作，但是放在浏览器端同步就变得不现实，javascript是单线程的，面对耗时操作我们应该如何处理，很简单那就是回调

   回调函数处处看可见，比如事件的处理，http请求操作，文件io操作等等，当遇到耗时操作返回时，javascript runtime 会立即执行这个函数
## 时间和空间
   同步操作是一条一条向下执行的，在这个时间上的变量的值是唯一确定的，但是这个异步操作的完成事件未知，所以这个变量当时的值也是不确定的，要想当值确定下来再去执行异步操作，那只能回调嵌入回调，这样一层一层就会造成回调地狱
## 现在目前主流的解决方案就是promises
   ES6 解决回调问题引入了promise。promiase代表了异步程序，并在未来某个时刻完成
   但是promise有自身的缺陷
    1. 数据源产生多个的时候无法很好的处理.
    2. 没有失败重置机制
    3. 没有取消的机制
#  这个时候 Rxjs闪亮登场。

## Rx可以解决什么问题那 
   1.我们普遍使用的for，while对于异步程序是无法感知的，不会等待异步程序结束再 进行下一轮
   2. 错误处理是任何程序都需要解决的问题，本身加入try/catch就很困难的程序再加加入重试机制就显得不现实
   3. 商业逻辑内嵌在回调函数中,可读性差,维护起来复杂,耦合度过高
   4. 可以根据事件或耗时的无响应的时间进行取消操作
   5. 时间监听带来内存泄漏问题
## 所以Rxjs可以优雅的代替callback
   Rxjs就是利用javascript实现的响应式编程 何谓响应时编程,就可以简单的理解为是变量某一时刻   发生变化和这个变量有关的变量进行相应的变化

## Rxjs中的组件，在Rxjs中万物都是Stream
+ 生产者：在Rxjs中的生产者叫做Observables，Observables负责推送事件，但是不处理   事件
+ 消费者：在Rxjs中的消费者叫做Observer
    ```
        数据只会从生产者流向消费者
    ```
+ 管道：在生产者流向消费者这个过程就形成管道，管道上的一个一个函数叫做 observable operator，简称opearators
+ 时间: 异步处理的不稳定性就是时间问题，因为异步操作你本来就不知道它什么具体时间结束，但是Rxjs就是面向异步编程的解决方案，时间遍布每一个角落，可以让时间变得相对稳定
## 响应式编程与其他编程思想区别
   Rxjs编程以时间遍布所以永不记录状态，面向对象是面向那个状态的，而响应式编程是面向行为的，我们可以用面向对象构建模型，用响应式编程来构建行为和事件处理。

## Rxjs 与函数式编程
   Rxjs是响应式的编程，说到响应式编程总和函数式编程有关。他俩到底有什么关系？
   响应式编程继承自函数式编程
    Rxjs是结合观察者模式，迭代器模式和函数式编程的优点的产物
   问题又来了什么是观察者模式？
   观察者模式是软件设计模式的一种（有时又被称为发布-订阅模式），自身状态通过通过呼叫观察者自身的提供的方法来实现
   首先我们逐个攻破
   1. 函数式编程是一种开发软件的范式，强调用函数来创建应用程序，最大特点链式调用，声明式的，不可变的，没有副作用的叫做函数式编程的三大护法
   2. 迭代器模式 Rxjs的关键设计理念是遍历机制。用遍历机制通知生产者发送数据
   3. Rxjs 鼓励用数据驱动模式进行开发，把数据和处理数据分隔开来，这是Rxjs涉及的核心。用同样的方式处理不同的数据源
##  Observable
   我们知道Observe是个容器，里面包含着数据，数据从何而来？
   ## 静态数据 ##
   我们日常重度使用的`string和array`都属于此范畴
   ## 动态数据 ##
   动态生成的数据

   Observables 发送事件，Observer异步的接受事件，这让我们的应用在有大量时间产生的时候保持响应能力。强调一下，Rxjs不仅面向客户端也面向服务端

   ```
        Rx.observable.from(<数据源>)
            .operator(...)
            .operator(...)
            .operator(...)
            .subscrible(<处理最终结果数据>)
   ```
再次强调一下
1. observables是个不可变的数据类型
2. observables不仅仅代表了当前的数据，更代表了未来某个时刻的数据

## 何时何地用Rxjs ##
   时间没有万能药，也没有能解决一切的代码，Rxjs也一样，只能在适合他的时候使用
   我们把一个程序按照两个维度划分成一个田字表格，横向是单值，多值，纵向是同步异步。
## 单值，同步
```
    Rx.observable.of(2017)
```
一旦有消费者消费，此值马上被发送出去。这种情况下使用Rxjs显得有点重了，除非我们进行合并流的操作
## 多值，同步
```
    Rx.observable.from([1,2,3])
```
from() 函数可能是Rxjs最常用的之一了。同步意思是啥就是执行1，在执行2，在执行3
## 单值，异步
这个情况就是Promise。Rxjs提供的函数无缝接轨到Promise
```
    const one = new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(1);
            },3000)
        }) //模拟3秒延迟
    //这个时候promise已经在执行了
    Rx.observable.fromPromise(one)
    .map(value=>value+1)
    .subscribe(result => {
        console.log(result)
        })
    console.log('打印结束');
```































